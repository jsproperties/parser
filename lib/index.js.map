{"version":3,"sources":["../src/index.js"],"names":["parseToEntries","parseToProperties","entriesToProperties","PropertiesParser","parseToEntriesOptions","parseToPropertiesOptions","input","options","parseOptions","parse","entries","properties","entry","key","element","unescapeProperty","namespace","namespacedKey","parseNamespace","property","forEach","name","i","length","availableOptionNames","option","output","replace","match","code","SyntaxError","String","fromCharCode","parseInt","escaped","split","exports"],"mappings":"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","file":"index.js","sourcesContent":["// Import PEG.js generated parser through pegjs-loader\nimport * as PropertiesParser from './properties.pegjs';\n\n\nconst parseToEntriesOptions = [\n  'all',        // Include empty and blank lines\n  'original',   // Include original logical line in output\n  'eol',        // Include eol (end of line) in output\n  'location',   // Include location info in output\n];\n\nconst parseToPropertiesOptions = [\n  'namespace',  // Parse dot separated keys as namespaced\n];\n\n\n/**\n * Parse .properties file content to an array of object containing key, element,\n * and optionally original line and location.\n * @param {string} input Properties file content in string.\n * @param {*} [options] Options for parsing.\n * @returns {Array} Parsed result in array.\n */\nexport function parseToEntries(input, options) {\n  options = parseOptions(options, parseToEntriesOptions);\n  return PropertiesParser.parse(input, options);\n}\n\n/**\n * Parse .properties file content to a properties object, with property key as\n * the key and property element as the value.\n * @param {string} input Properties file content in string.\n * @param {*} [options] Options for parsing.\n * @returns {object} Parsed result in properties object.\n */\nexport function parseToProperties(input, options) {\n  let entries = parseToEntries(input);\n  return entriesToProperties(entries, options);\n}\n\n/**\n * Convert parsed entries to a properties object.\n * @param {Array} entries Entries to be converted.\n * @param {Object} [options] Options for converting\n * @returns {object} Converted properties object.\n */\nexport function entriesToProperties(entries, options) {\n  options = parseOptions(options, parseToPropertiesOptions);\n  let properties = {};\n\n  for (let entry of entries) {\n    // Only key and element are relevant\n    let { key, element } = entry;\n\n    // Blank and comment lines are ignored\n    if (key === null) continue;\n\n    // Parsed array adheres to what user authored,\n    // while in properties, we need to unescape backslashes.\n    key = unescapeProperty(key);\n    element = unescapeProperty(element);\n\n    // Assign to properties by key, later entries overwrite previous ones\n    if (options.namespace) {\n      let namespacedKey = parseNamespace(key);\n      let property = properties;\n      namespacedKey.forEach((name, i) => {\n        // This is the last component of the key\n        if (i === namespacedKey.length - 1) {\n          property[name] = element;\n          return;\n        }\n\n        // This is part of the namespace\n        if (name in property) {\n          // Namespace itself and keys under it may all have values\n          // e.g. \"foo = bar\" \"foo.qux = quux\"\n          if (typeof property[name] === 'string') {\n            // Make value of namespace a value of an empty key under the\n            // namespace\n            property[name] = { '': property[name] };\n          }\n        } else {\n          property[name] = {};\n        }\n        property = property[name];\n      });\n    } else {\n      properties[key] = element;\n    }\n  }\n\n  return properties;\n}\n\n\n/**\n * Normalize options.\n * @param {*} options Options to be parsed; it can be object, boolean, null or undefined.\n * @param {!Array<string>} availableOptionNames All possible option names.\n * @returns {object} Normalized options.\n */\nfunction parseOptions(options, availableOptionNames) {\n  // Fix `null`, `false` as the options\n  options = options || {};\n\n  // `true` is a shortcut to turn all options on\n  if (options === true) {\n    options = {};\n    for (let option of availableOptionNames) {\n      options[option] = true;\n    }\n    return options;\n  }\n\n  // { '': true } is also a shorcut to turn all options on, while allow\n  // individual options to be turned off by setting them explicitly.\n  if (typeof options[''] === 'boolean') {\n    for (let option of availableOptionNames) {\n      if (!(option in options)) {\n        options[option] = options[''];\n      }\n    }\n  }\n\n  return options;\n}\n\n/**\n * Unescape backslash escaped sequences.\n * @param {string} input String to be mutated.\n * @returns {string} Unescaped input.\n * @throws {SyntaxError} Invalid Unicode escape sequence\n */\nfunction unescapeProperty(input) {\n  // Unescape unicode\n  let output = input.replace(/\\\\u([0-9A-Fa-f]{0,4})/g, (match, code) => {\n    if (code.length !== 4) throw new SyntaxError('Invalid Unicode escape sequence');\n    return String.fromCharCode(parseInt(code, 16));\n  });\n\n  // Unescape other single character\n  return output.replace(/\\\\(.)/g, (match, escaped) => {\n    switch (escaped) {\n      case 'f': return '\\f';\n      case 'n': return '\\n';\n      case 'r': return '\\r';\n      case 't': return '\\t';\n      default: return escaped;\n    }\n  });\n}\n\n/**\n * Turn dot separated string into an array of relevant components.\n * @param {string} key The dot separated string.\n * @returns {Array} Array of key components.\n */\nfunction parseNamespace(key) {\n  return key.split('.');\n}\n\n\n// Export everything this module exports as a default export\nexport default exports;\n"]}