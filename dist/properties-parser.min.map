{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap fb50a5a07e3c72fd2c5c","webpack:///./src/index.js","webpack:///./src/properties.pegjs"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","n","__esModule","object","property","prototype","hasOwnProperty","p","s","_properties","keys","forEach","key","parseToArray","parseToProperties","arrayToProperties","PropertiesParser","parseToArrayOptions","parseToPropertiesOptions","input","options","parseOptions","parse","array","properties","_loop","entry","element","unescapeBackslashes","namespace","namespacedKey","split","length","","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","Symbol","iterator","next","done","value","err","return","availableOptionNames","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","option","replace","peg$SyntaxError","message","expected","found","location","Error","captureStackTrace","child","parent","ctor","constructor","peg$subclass","buildMessage","DESCRIBE_EXPECTATION_FNS","literal","expectation","literalEscape","text","class","escapedParts","parts","Array","classEscape","inverted","any","end","other","description","hex","ch","charCodeAt","toString","toUpperCase","j","descriptions","type","sort","slice","join","describeExpected","SyntaxError","peg$result","peg$FAILED","peg$startRuleFunctions","PropertiesFile","peg$parsePropertiesFile","peg$startRuleFunction","peg$c0","lines","trailing","push","filter","x","peg$c1","line","eol","peg$c2","all","original","peg$c3","start","offset","peg$c4","peg$c5","peg$otherExpectation","peg$c6","peg$c7","peg$classExpectation","peg$c8","sep","peg$c9","peg$c10","peg$c11","peg$c12","a","peg$c13","peg$c14","peg$c15","b","peg$c16","peg$c17","v","peg$c18","peg$c19","peg$c20","peg$c21","peg$c22","peg$c23","peg$c24","peg$c25","peg$c26","peg$c27","peg$c28","peg$c29","peg$c30","peg$c31","peg$literalExpectation","peg$c32","peg$c33","peg$c34","peg$c35","peg$c36","peg$c37","peg$c38","peg$c39","peg$currPos","peg$savedPos","peg$posDetailsCache","column","peg$maxFailPos","peg$maxFailExpected","peg$silentFails","startRule","substring","peg$computeLocation","ignoreCase","peg$computePosDetails","pos","details","startPos","endPos","startPosDetails","endPosDetails","peg$fail","peg$buildStructuredError","s0","s1","s2","peg$parseFullLine","peg$parseLine","peg$parseTrailingLine","peg$parseNL","s3","peg$parse_","peg$parseCONT","test","charAt","peg$parseCommentCharacter","peg$parseC","peg$parseComment","s4","peg$parseESCAPE","peg$parsePropertyKey","s5","peg$parseWS","peg$parseKeyElementSeparator","peg$parsePropertyElement","peg$parsePropertyEntry","substr"],"mappings":"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","file":"properties-parser.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PropertiesParser\"] = factory();\n\telse\n\t\troot[\"PropertiesParser\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap fb50a5a07e3c72fd2c5c","// Import PEG.js generated parser through pegjs-loader\nimport * as PropertiesParser from './properties.pegjs';\n\n// Reexport everything PEG.js generated parser exports\nexport * from './properties.pegjs';\n\n\nconst parseToArrayOptions = [\n  'all',        // Include empty and blank lines\n  'original',   // Include original logical line in output\n  'eol',        // Include eol (end of line) in output\n  'location',   // Include location info in output\n];\n\nconst parseToPropertiesOptions = [\n  'namespace',  // Parse dot separated keys as namespaced\n];\n\n\n/**\n * Parse .properties file content to an array of object containing key, element,\n * and optionally original line and location.\n * @param {string} input Properties file content in string.\n * @param {*} [options] Options for parsing.\n * @returns {Array} Parsed result in array.\n */\nexport function parseToArray(input, options) {\n  options = parseOptions(options, parseToArrayOptions);\n  return PropertiesParser.parse(input, options);\n}\nPropertiesParser.parseToArray = parseToArray;\n\n/**\n * Parse .properties file content to a properties object, with property key as\n * the key and property element as the value.\n * @param {string} input Properties file content in string.\n * @param {*} [options] Options for parsing.\n * @returns {object} Parsed result in properties object.\n */\nexport function parseToProperties(input, options) {\n  let parsedArray = parseToArray(input);\n  return arrayToProperties(parsedArray, options);\n}\nPropertiesParser.parseToProperties = parseToProperties;\n\n/**\n * Convert parsed array to a properties object.\n * @param {Array} array The source array to be converted.\n * @param {Object} [options] Options for converting\n * @returns {object} Converted properties object.\n */\nexport function arrayToProperties(array, options) {\n  options = parseOptions(options, parseToPropertiesOptions);\n  let properties = {};\n\n  for (let entry of array) {\n    // Only key and element are relevant\n    let { key, element } = entry;\n\n    // Blank and comment lines are ignored\n    if (key === null) continue;\n\n    // Parsed array adheres to what user authored,\n    // while in properties, we need to unescape backslashes.\n    key = unescapeBackslashes(key);\n    element = unescapeBackslashes(element);\n\n    // Assign to properties by key, later entries overwrite previous ones\n    if (options.namespace) {\n      let namespacedKey = parseNamespace(key);\n      let property = properties;\n      namespacedKey.forEach((name, i) => {\n        // This is the last component of the key\n        if (i === namespacedKey.length - 1) {\n          property[name] = element;\n          return;\n        }\n\n        // This is part of the namespace\n        if (name in property) {\n          // Namespace itself and keys under it may all have values\n          // e.g. \"foo = bar\" \"foo.qux = quux\"\n          if (typeof property[name] === 'string') {\n            // Make value of namespace a value of an empty key under the\n            // namespace\n            property[name] = { '': property[name] };\n          }\n        } else {\n          property[name] = {};\n        }\n        property = property[name];\n      });\n    } else {\n      properties[key] = element;\n    }\n  }\n\n  return properties;\n}\nPropertiesParser.arrayToProperties = arrayToProperties;\n\n\n/**\n * Normalize options.\n * @param {*} options Options to be parsed; it can be object, boolean, null or undefined.\n * @param {!Array<string>} availableOptionNames All possible option names.\n * @returns {object} Normalized options.\n */\nfunction parseOptions(options, availableOptionNames) {\n  // Fix `null`, `false` as the options\n  options = options || {};\n\n  // `true` is a shortcut to turn all options on\n  if (options === true) {\n    options = {};\n    for (let option of availableOptionNames) {\n      options[option] = true;\n    }\n    return options;\n  }\n\n  // { '': true } is also a shorcut to turn all options on, while allow\n  // individual options to be turned off by setting them explicitly.\n  if (typeof options[''] === 'boolean') {\n    for (let option of availableOptionNames) {\n      if (!(option in options)) {\n        options[option] = options[''];\n      }\n    }\n  }\n\n  return options;\n}\n\n/**\n * Replce '\\\\\\\\' sequence with '\\\\' character.\n * @param {string} input String to be mutated.\n * @returns {string} Unescaped input.\n */\nfunction unescapeBackslashes(input) {\n  return input.replace(/\\\\\\\\/g, '\\\\');\n}\n\n/**\n * Turn dot separated string into an array of relevant components.\n * @param {string} key The dot separated string.\n * @returns {Array} Array of key components.\n */\nfunction parseNamespace(key) {\n  return key.split('.');\n}\n\n\n// Export everything this module exports as a default export\nexport default PropertiesParser;\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","/*\n * Generated by PEG.js 0.10.0.\n *\n * http://pegjs.org/\n */\n\n\"use strict\";\n\nfunction peg$subclass(child, parent) {\n  function ctor() { this.constructor = child; }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  this.message  = message;\n  this.expected = expected;\n  this.found    = found;\n  this.location = location;\n  this.name     = \"SyntaxError\";\n\n  if (typeof Error.captureStackTrace === \"function\") {\n    Error.captureStackTrace(this, peg$SyntaxError);\n  }\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n        literal: function(expectation) {\n          return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n        },\n\n        \"class\": function(expectation) {\n          var escapedParts = \"\",\n              i;\n\n          for (i = 0; i < expectation.parts.length; i++) {\n            escapedParts += expectation.parts[i] instanceof Array\n              ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1])\n              : classEscape(expectation.parts[i]);\n          }\n\n          return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n        },\n\n        any: function(expectation) {\n          return \"any character\";\n        },\n\n        end: function(expectation) {\n          return \"end of input\";\n        },\n\n        other: function(expectation) {\n          return expectation.description;\n        }\n      };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\"/g,  '\\\\\"')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\\]/g, '\\\\]')\n      .replace(/\\^/g, '\\\\^')\n      .replace(/-/g,  '\\\\-')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = new Array(expected.length),\n        i, j;\n\n    for (i = 0; i < expected.length; i++) {\n      descriptions[i] = describeExpectation(expected[i]);\n    }\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \")\n          + \", or \"\n          + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== void 0 ? options : {};\n\n  var peg$FAILED = {},\n\n      peg$startRuleFunctions = { PropertiesFile: peg$parsePropertiesFile },\n      peg$startRuleFunction  = peg$parsePropertiesFile,\n\n      peg$c0 = function(lines, trailing) {\n            // Add the trailing line, i.e. line without eol\n            if (trailing) lines.push(trailing);\n            // Filter out blank and comment lines\n            return lines.filter(x => x !== undefined);\n          },\n      peg$c1 = function(line, eol) {\n            if (!line) return;\n            if (options.eol) line.eol = eol;\n            return line;\n          },\n      peg$c2 = function(line) {\n            if (!line) {\n              if (options.all) {\n                line = { key: null, element: null };\n              } else {\n                return undefined;\n              }\n            }\n\n            if (options.original) line.original = text();\n            if (options.eol) line.eol = null;\n            if (options.location) line.location = location();\n\n            return line;\n          },\n      peg$c3 = function(line) {\n            // If the offset of start and end match, there is actually no trailing\n            // line; TrailingLine is matched in this case because a line itself\n            // (not counting eol) may contain no characters.\n            return location().start.offset === location().end.offset ?\n                undefined : line;\n          },\n      peg$c4 = function() {},\n      peg$c5 = peg$otherExpectation(\"CommentCharacter\"),\n      peg$c6 = /^[#!]/,\n      peg$c7 = peg$classExpectation([\"#\", \"!\"], false, false),\n      peg$c8 = function(key, sep, element) {\n            // Blank Line:\n            // No need to test element, as whenever there is an element, there is a separator.\n            // Note: Key and element can be empty at the same time.\n            if (!key && !sep) return;\n\n            // Property Entry:\n            // Return an empty string for key and/or element if empty.\n            return { key: key || \"\", element: element || \"\" };\n          },\n      peg$c9 = peg$otherExpectation(\"PropertyKey\"),\n      peg$c10 = /^[^\\r\\n\\\\:=]/,\n      peg$c11 = peg$classExpectation([\"\\r\", \"\\n\", \"\\\\\", \":\", \"=\"], true, false),\n      peg$c12 = function(a) {},\n      peg$c13 = /^[^ \\t\\f\\r\\n\\\\:=]/,\n      peg$c14 = peg$classExpectation([\" \", \"\\t\", \"\\f\", \"\\r\", \"\\n\", \"\\\\\", \":\", \"=\"], true, false),\n      peg$c15 = function(a, b) { return a + b.join(''); },\n      peg$c16 = peg$otherExpectation(\"PropertyElement\"),\n      peg$c17 = function(v) { return v.join(''); },\n      peg$c18 = peg$otherExpectation(\"KeyElementSeparator\"),\n      peg$c19 = /^[:=]/,\n      peg$c20 = peg$classExpectation([\":\", \"=\"], false, false),\n      peg$c21 = peg$otherExpectation(\"White Space\"),\n      peg$c22 = /^[ \\t\\f]/,\n      peg$c23 = peg$classExpectation([\" \", \"\\t\", \"\\f\"], false, false),\n      peg$c24 = peg$otherExpectation(\"White Spaces\"),\n      peg$c25 = peg$otherExpectation(\"Character\"),\n      peg$c26 = /^[^\\r\\n]/,\n      peg$c27 = peg$classExpectation([\"\\r\", \"\\n\"], true, false),\n      peg$c28 = function(c) {\n            // Ignore final dangling backslash\n            return c === \"\\\\\" ? undefined : c;\n          },\n      peg$c29 = peg$otherExpectation(\"Line Terminator\"),\n      peg$c30 = \"\\r\\n\",\n      peg$c31 = peg$literalExpectation(\"\\r\\n\", false),\n      peg$c32 = /^[\\n\\r]/,\n      peg$c33 = peg$classExpectation([\"\\n\", \"\\r\"], false, false),\n      peg$c34 = peg$otherExpectation(\"Line Continuation\"),\n      peg$c35 = \"\\\\\",\n      peg$c36 = peg$literalExpectation(\"\\\\\", false),\n      peg$c37 = peg$otherExpectation(\"Escape Sequence\"),\n      peg$c38 = peg$anyExpectation(),\n      peg$c39 = function() { return text(); },\n\n      peg$currPos          = 0,\n      peg$savedPos         = 0,\n      peg$posDetailsCache  = [{ line: 1, column: 1 }],\n      peg$maxFailPos       = 0,\n      peg$maxFailExpected  = [],\n      peg$silentFails      = 0,\n\n      peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation() {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos], p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line:   details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos) {\n    var startPosDetails = peg$computePosDetails(startPos),\n        endPosDetails   = peg$computePosDetails(endPos);\n\n    return {\n      start: {\n        offset: startPos,\n        line:   startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line:   endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$parsePropertiesFile() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parseFullLine();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parseFullLine();\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseTrailingLine();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c0(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseFullLine() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = peg$parseLine();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseNL();\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseLine() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parse_();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parseCONT();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parseCONT();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseComment();\n        if (s3 === peg$FAILED) {\n          s3 = peg$parsePropertyEntry();\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c2(s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseTrailingLine() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    s1 = peg$parseLine();\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c3(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseComment() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parseCommentCharacter();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parseC();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parseC();\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c4();\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseCommentCharacter() {\n    var s0, s1;\n\n    peg$silentFails++;\n    if (peg$c6.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c7); }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c5); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsePropertyEntry() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsePropertyKey();\n    if (s1 === peg$FAILED) {\n      s1 = null;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      s3 = peg$parseKeyElementSeparator();\n      if (s3 === peg$FAILED) {\n        s3 = null;\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = input.substring(s2, peg$currPos);\n      } else {\n        s2 = s3;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsePropertyElement();\n        if (s3 === peg$FAILED) {\n          s3 = null;\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c8(s1, s2, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsePropertyKey() {\n    var s0, s1, s2, s3, s4;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$parseESCAPE();\n    if (s1 === peg$FAILED) {\n      if (peg$c10.test(input.charAt(peg$currPos))) {\n        s1 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s1 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c11); }\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parseCONT();\n      if (s4 !== peg$FAILED) {\n        peg$savedPos = s3;\n        s4 = peg$c12(s1);\n      }\n      s3 = s4;\n      if (s3 === peg$FAILED) {\n        s3 = peg$parseESCAPE();\n        if (s3 === peg$FAILED) {\n          if (peg$c13.test(input.charAt(peg$currPos))) {\n            s3 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s3 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c14); }\n          }\n        }\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parseCONT();\n        if (s4 !== peg$FAILED) {\n          peg$savedPos = s3;\n          s4 = peg$c12(s1);\n        }\n        s3 = s4;\n        if (s3 === peg$FAILED) {\n          s3 = peg$parseESCAPE();\n          if (s3 === peg$FAILED) {\n            if (peg$c13.test(input.charAt(peg$currPos))) {\n              s3 = input.charAt(peg$currPos);\n              peg$currPos++;\n            } else {\n              s3 = peg$FAILED;\n              if (peg$silentFails === 0) { peg$fail(peg$c14); }\n            }\n          }\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c15(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c9); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsePropertyElement() {\n    var s0, s1, s2, s3;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$currPos;\n    s3 = peg$parseCONT();\n    if (s3 !== peg$FAILED) {\n      peg$savedPos = s2;\n      s3 = peg$c4();\n    }\n    s2 = s3;\n    if (s2 === peg$FAILED) {\n      s2 = peg$parseESCAPE();\n      if (s2 === peg$FAILED) {\n        s2 = peg$parseC();\n      }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$currPos;\n        s3 = peg$parseCONT();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s2;\n          s3 = peg$c4();\n        }\n        s2 = s3;\n        if (s2 === peg$FAILED) {\n          s2 = peg$parseESCAPE();\n          if (s2 === peg$FAILED) {\n            s2 = peg$parseC();\n          }\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c17(s1);\n    }\n    s0 = s1;\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c16); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseKeyElementSeparator() {\n    var s0, s1, s2, s3, s4, s5;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parseCONT();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parseCONT();\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$currPos;\n      s3 = peg$parse_();\n      if (s3 !== peg$FAILED) {\n        s4 = [];\n        s5 = peg$parseCONT();\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = peg$parseCONT();\n        }\n        if (s4 !== peg$FAILED) {\n          if (peg$c19.test(input.charAt(peg$currPos))) {\n            s5 = input.charAt(peg$currPos);\n            peg$currPos++;\n          } else {\n            s5 = peg$FAILED;\n            if (peg$silentFails === 0) { peg$fail(peg$c20); }\n          }\n          if (s5 !== peg$FAILED) {\n            s3 = [s3, s4, s5];\n            s2 = s3;\n          } else {\n            peg$currPos = s2;\n            s2 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s2;\n          s2 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s2;\n        s2 = peg$FAILED;\n      }\n      if (s2 === peg$FAILED) {\n        s2 = peg$parseWS();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          s4 = [];\n          s5 = peg$parseCONT();\n          while (s5 !== peg$FAILED) {\n            s4.push(s5);\n            s5 = peg$parseCONT();\n          }\n          if (s4 !== peg$FAILED) {\n            s1 = [s1, s2, s3, s4];\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c18); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseWS() {\n    var s0, s1;\n\n    peg$silentFails++;\n    if (peg$c22.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c23); }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c21); }\n    }\n\n    return s0;\n  }\n\n  function peg$parse_() {\n    var s0, s1;\n\n    peg$silentFails++;\n    s0 = [];\n    s1 = peg$parseWS();\n    while (s1 !== peg$FAILED) {\n      s0.push(s1);\n      s1 = peg$parseWS();\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c24); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseC() {\n    var s0, s1;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (peg$c26.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c27); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c28(s1);\n    }\n    s0 = s1;\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c25); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseNL() {\n    var s0, s1;\n\n    peg$silentFails++;\n    if (input.substr(peg$currPos, 2) === peg$c30) {\n      s0 = peg$c30;\n      peg$currPos += 2;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c31); }\n    }\n    if (s0 === peg$FAILED) {\n      if (peg$c32.test(input.charAt(peg$currPos))) {\n        s0 = input.charAt(peg$currPos);\n        peg$currPos++;\n      } else {\n        s0 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c33); }\n      }\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c29); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseCONT() {\n    var s0, s1, s2, s3;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    if (input.charCodeAt(peg$currPos) === 92) {\n      s1 = peg$c35;\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c36); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parseNL();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parse_();\n        if (s3 !== peg$FAILED) {\n          s1 = [s1, s2, s3];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c34); }\n    }\n\n    return s0;\n  }\n\n  function peg$parseESCAPE() {\n    var s0, s1, s2, s3;\n\n    peg$silentFails++;\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    peg$silentFails++;\n    s2 = peg$parseCONT();\n    peg$silentFails--;\n    if (s2 === peg$FAILED) {\n      s1 = void 0;\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 92) {\n        s2 = peg$c35;\n        peg$currPos++;\n      } else {\n        s2 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c36); }\n      }\n      if (s2 !== peg$FAILED) {\n        if (input.length > peg$currPos) {\n          s3 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c38); }\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c39();\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    peg$silentFails--;\n    if (s0 === peg$FAILED) {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c37); }\n    }\n\n    return s0;\n  }\n\n\n    // Whether to include blank and comment lines\n    //options.all = true;\n    // Whether to include the original logical line\n    //options.original = true;\n    // Whether to include eol (end of line)\n    //options.eol = true;\n    // Whether to include location info\n    //options.location = true;\n\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\nmodule.exports = {\n  SyntaxError: peg$SyntaxError,\n  parse:       peg$parse\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/properties.pegjs"],"sourceRoot":""}