{"version":3,"sources":["../src/stringify.js"],"names":["stringify","stringifyFromEntries","stringifyFromProperties","input","options","Array","entries","parseOptions","output","entry","key","element","sep","indent","eol","original","properties","namespace","escapeKey","escapeElement","replace","match"],"mappings":";;;;;;;;QAMgBA,S,GAAAA,S;QAeAC,oB,GAAAA,oB;QAiCAC,uB,GAAAA,uB;AAtDhB;;;;;;AAMO,SAASF,SAAT,CAAmBG,KAAnB,EAA0BC,OAA1B,EAAmC;AACxC,MAAID,iBAAiBE,KAArB,EAA4B;AAC1B,WAAOJ,qBAAqBE,KAArB,EAA4BC,OAA5B,CAAP;AACD;;AAED,SAAOF,wBAAwBC,KAAxB,EAA+BC,OAA/B,CAAP;AACD;;AAED;;;;;;;AAOO,SAASH,oBAAT,CAA8BK,OAA9B,EAAuCF,OAAvC,EAAgD;AACrDA,YAAUG,aAAaH,OAAb,CAAV;;AAEA,MAAII,SAAS,EAAb;AAHqD;AAAA;AAAA;;AAAA;AAIrD,yBAAkBF,OAAlB,8HAA2B;AAAA,UAAlBG,KAAkB;AAAA,UACjBC,GADiB,GACAD,KADA,CACjBC,GADiB;AAAA,UACZC,OADY,GACAF,KADA,CACZE,OADY;;AAEzB,UAAMC,MAAMH,MAAMG,GAAN,IAAaR,QAAQQ,GAAjC;AACA,UAAMC,SAASJ,MAAMI,MAAN,IAAgB,EAA/B;AACA,UAAMC,MAAM,SAASL,KAAT,GACRA,MAAMK,GAAN,IAAa,EADL,CACU;AADV,QAERV,QAAQU,GAFZ;;AAIA;AACA,UAAIL,MAAMM,QAAN,IAAkB,IAAtB,EAA4B;AAC1BP,kBAAUC,MAAMM,QAAhB;AACD,OAFD,MAEO;AACL;AACAP,kBAAUE,OAAO,IAAP,IAAeC,WAAW,IAA1B,GACN,EADM,GACDE,SAASH,GAAT,GAAeE,GAAf,GAAqBD,OAD9B;AAED;;AAEDH,gBAAUM,GAAV;AACD;AAtBoD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAwBrD,SAAON,MAAP;AACD;;AAED;;;;;;AAMO,SAASN,uBAAT,CAAiCc,UAAjC,EAA6CZ,OAA7C,EAAsD;AAC3DA,YAAUG,aAAaH,OAAb,CAAV;;AAEA,MAAII,SAAS,EAAb;AACA,OAAK,IAAIE,GAAT,IAAgBM,UAAhB,EAA4B;AAC1B,QAAIL,UAAUK,WAAWN,GAAX,CAAd;AACA,QAAI,OAAOC,OAAP,KAAmB,QAAvB,EAAiC;AAC/B,UAAIP,QAAQa,SAAZ,EAAuB;AACrBT,kBAAUU,UAAUd,QAAQa,SAAlB,CAAV;;AAEA;AACA,YAAIP,GAAJ,EAAS;AACPF,oBAAU,GAAV;AACD;AACF;AACDA,gBAAUU,UAAUR,GAAV,IACNN,QAAQQ,GADF,GAENO,cAAcR,OAAd,CAFM,GAGNP,QAAQU,GAHZ;AAID,KAbD,MAaO;AACL;AACA,UAAIG,YAAYb,QAAQa,SAAR,GACZb,QAAQa,SAAR,GAAoB,GAApB,GAA0BP,GADd,GAEZA,GAFJ;AAGAF,gBAAUN,wBAAwBS,OAAxB,EACN,SAAc,EAAd,EAAkBP,OAAlB,EAA2B,EAAEa,WAAWA,SAAb,EAA3B,CADM,CAAV;AAED;AACF;;AAED,SAAOT,MAAP;AACD;;AAED;;;;;AAKA,SAASD,YAAT,CAAsBH,OAAtB,EAA+B;AAC7BA,YAAUA,WAAW,EAArB;AACAA,UAAQQ,GAAR,GAAcR,QAAQQ,GAAR,IAAe,KAA7B;AACAR,UAAQU,GAAR,GAAcV,QAAQU,GAAR,IAAe,MAA7B;AACA,SAAOV,OAAP;AACD;;AAED;;;;;AAKA,SAASc,SAAT,CAAmBR,GAAnB,EAAwB;AACtB,SAAOA,IAAIU,OAAJ,CAAY,SAAZ,EAAuB,UAACC,KAAD,EAAW;AACvC,YAAQA,KAAR;AACE,WAAK,GAAL;AAAU,eAAO,KAAP;AACV,WAAK,GAAL;AAAU,eAAO,KAAP;AACV,WAAK,GAAL;AAAU,eAAO,KAAP;AACV;AAAS,eAAOF,cAAcE,KAAd,CAAP;AAJX;AAMD,GAPM,CAAP;AAQD;;AAED;;;;;AAKA,SAASF,aAAT,CAAuBR,OAAvB,EAAgC;AAC9B,SAAOA,QAAQS,OAAR,CAAgB,SAAhB,EAA2B,UAACC,KAAD,EAAW;AAC3C,YAAQA,KAAR;AACE,WAAK,IAAL;AAAW,eAAO,MAAP;AACX,WAAK,IAAL;AAAW,eAAO,KAAP;AACX,WAAK,IAAL;AAAW,eAAO,KAAP;AACX,WAAK,IAAL;AAAW,eAAO,KAAP;AACX,WAAK,IAAL;AAAW,eAAO,KAAP;AACX;AAAS,eAAOA,KAAP;AANX;AAQD,GATM,CAAP;AAUD","file":"stringify.js","sourcesContent":["/**\n * Stringify properties object or entries to .properties file content.\n * @param {Array | Object} input Properties object or entries.\n * @param {Object} [options] Stringify options.\n * @returns {string} .properties file content.\n */\nexport function stringify(input, options) {\n  if (input instanceof Array) {\n    return stringifyFromEntries(input, options);\n  }\n\n  return stringifyFromProperties(input, options);\n}\n\n/**\n * Stringify entries to .properties file content.\n * @param {Array} entries Property entries.\n * @param {Object} [options] Stringify options, used when specified fields are\n *     not available in each entry.\n * @returns {string} .properties file content.\n */\nexport function stringifyFromEntries(entries, options) {\n  options = parseOptions(options);\n\n  let output = '';\n  for (let entry of entries) {\n    const { key, element } = entry;\n    const sep = entry.sep || options.sep;\n    const indent = entry.indent || '';\n    const eol = 'eol' in entry\n      ? entry.eol || ''   // Use empty string in case eol is null.\n      : options.eol;\n\n    // Prefer original if available\n    if (entry.original != null) {\n      output += entry.original;\n    } else {\n      // Output a blank line for blank and comment entry\n      output += key == null || element == null\n        ? '' : indent + key + sep + element;\n    }\n\n    output += eol;\n  }\n\n  return output;\n}\n\n/**\n * Stringify properties object to .properties file content.\n * @param {Object} properties Properties object.\n * @param {Object} [options] Stringify options.\n * @returns {string} .properties file content.\n */\nexport function stringifyFromProperties(properties, options) {\n  options = parseOptions(options);\n\n  let output = '';\n  for (let key in properties) {\n    let element = properties[key];\n    if (typeof element === 'string') {\n      if (options.namespace) {\n        output += escapeKey(options.namespace);\n\n        // Add a dot after namespace if key is not empty\n        if (key) {\n          output += '.';\n        }\n      }\n      output += escapeKey(key) +\n          options.sep +\n          escapeElement(element) +\n          options.eol;\n    } else {\n      // Namespaced properties\n      let namespace = options.namespace\n        ? options.namespace + '.' + key\n        : key;\n      output += stringifyFromProperties(element,\n          Object.assign({}, options, { namespace: namespace }));\n    }\n  }\n\n  return output;\n}\n\n/**\n * Normalize user provided options.\n * @param {*} options Original options.\n * @returns {Object} Normalized options.\n */\nfunction parseOptions(options) {\n  options = options || {};\n  options.sep = options.sep || ' = ';\n  options.eol = options.eol || '\\r\\n';\n  return options;\n}\n\n/**\n * Escape special characters in property key.\n * @param {string} key Key to be mutated.\n * @returns {string} Escaped key.\n */\nfunction escapeKey(key) {\n  return key.replace(/[\\s\\S]/g, (match) => {\n    switch (match) {\n      case '=': return '\\\\=';\n      case ':': return '\\\\:';\n      case ' ': return '\\\\ ';\n      default: return escapeElement(match);\n    }\n  });\n}\n\n/**\n * Escape special characters in property element.\n * @param {string} element Element to be mutated.\n * @returns {string} Escaped element.\n */\nfunction escapeElement(element) {\n  return element.replace(/[\\s\\S]/g, (match) => {\n    switch (match) {\n      case '\\\\': return '\\\\\\\\';\n      case '\\f': return '\\\\f';\n      case '\\n': return '\\\\n';\n      case '\\r': return '\\\\r';\n      case '\\t': return '\\\\t';\n      default: return match;\n    }\n  });\n}\n"]}