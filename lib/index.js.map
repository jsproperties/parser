{"version":3,"sources":["../src/index.js"],"names":["parseToArray","parseToProperties","arrayToProperties","PropertiesParser","parseToArrayOptions","parseToPropertiesOptions","input","options","parseOptions","parse","parsedArray","array","properties","entry","key","element","unescapeBackslashes","namespace","namespacedKey","parseNamespace","property","forEach","name","i","length","availableOptionNames","option","replace","split"],"mappings":"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","file":"index.js","sourcesContent":["// Import PEG.js generated parser through pegjs-loader\nimport * as PropertiesParser from './properties.pegjs';\n\n// Reexport everything PEG.js generated parser exports\nexport * from './properties.pegjs';\n\n\nconst parseToArrayOptions = [\n  'all',        // Include empty and blank lines\n  'original',   // Include original logical line in output\n  'eol',        // Include eol (end of line) in output\n  'location',   // Include location info in output\n];\n\nconst parseToPropertiesOptions = [\n  'namespace',  // Parse dot separated keys as namespaced\n];\n\n\n/**\n * Parse .properties file content to an array of object containing key, element,\n * and optionally original line and location.\n * @param {string} input Properties file content in string.\n * @param {*} [options] Options for parsing.\n * @returns {Array} Parsed result in array.\n */\nexport function parseToArray(input, options) {\n  options = parseOptions(options, parseToArrayOptions);\n  return PropertiesParser.parse(input, options);\n}\nPropertiesParser.parseToArray = parseToArray;\n\n/**\n * Parse .properties file content to a properties object, with property key as\n * the key and property element as the value.\n * @param {string} input Properties file content in string.\n * @param {*} [options] Options for parsing.\n * @returns {object} Parsed result in properties object.\n */\nexport function parseToProperties(input, options) {\n  let parsedArray = parseToArray(input);\n  return arrayToProperties(parsedArray, options);\n}\nPropertiesParser.parseToProperties = parseToProperties;\n\n/**\n * Convert parsed array to a properties object.\n * @param {Array} array The source array to be converted.\n * @param {Object} [options] Options for converting\n * @returns {object} Converted properties object.\n */\nexport function arrayToProperties(array, options) {\n  options = parseOptions(options, parseToPropertiesOptions);\n  let properties = {};\n\n  for (let entry of array) {\n    // Only key and element are relevant\n    let { key, element } = entry;\n\n    // Blank and comment lines are ignored\n    if (key === null) continue;\n\n    // Parsed array adheres to what user authored,\n    // while in properties, we need to unescape backslashes.\n    key = unescapeBackslashes(key);\n    element = unescapeBackslashes(element);\n\n    // Assign to properties by key, later entries overwrite previous ones\n    if (options.namespace) {\n      let namespacedKey = parseNamespace(key);\n      let property = properties;\n      namespacedKey.forEach((name, i) => {\n        // This is the last component of the key\n        if (i === namespacedKey.length - 1) {\n          property[name] = element;\n          return;\n        }\n\n        // This is part of the namespace\n        if (name in property) {\n          // Namespace itself and keys under it may all have values\n          // e.g. \"foo = bar\" \"foo.qux = quux\"\n          if (typeof property[name] === 'string') {\n            // Make value of namespace a value of an empty key under the\n            // namespace\n            property[name] = { '': property[name] };\n          }\n        } else {\n          property[name] = {};\n        }\n        property = property[name];\n      });\n    } else {\n      properties[key] = element;\n    }\n  }\n\n  return properties;\n}\nPropertiesParser.arrayToProperties = arrayToProperties;\n\n\n/**\n * Normalize options.\n * @param {*} options Options to be parsed; it can be object, boolean, null or undefined.\n * @param {!Array<string>} availableOptionNames All possible option names.\n * @returns {object} Normalized options.\n */\nfunction parseOptions(options, availableOptionNames) {\n  // Fix `null`, `false` as the options\n  options = options || {};\n\n  // `true` is a shortcut to turn all options on\n  if (options === true) {\n    options = {};\n    for (let option of availableOptionNames) {\n      options[option] = true;\n    }\n    return options;\n  }\n\n  // { '': true } is also a shorcut to turn all options on, while allow\n  // individual options to be turned off by setting them explicitly.\n  if (typeof options[''] === 'boolean') {\n    for (let option of availableOptionNames) {\n      if (!(option in options)) {\n        options[option] = options[''];\n      }\n    }\n  }\n\n  return options;\n}\n\n/**\n * Replce '\\\\\\\\' sequence with '\\\\' character.\n * @param {string} input String to be mutated.\n * @returns {string} Unescaped input.\n */\nfunction unescapeBackslashes(input) {\n  return input.replace(/\\\\\\\\/g, '\\\\');\n}\n\n/**\n * Turn dot separated string into an array of relevant components.\n * @param {string} key The dot separated string.\n * @returns {Array} Array of key components.\n */\nfunction parseNamespace(key) {\n  return key.split('.');\n}\n\n\n// Export everything this module exports as a default export\nexport default PropertiesParser;\n"]}